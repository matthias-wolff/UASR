#!/usr/bin/env dlabpro
## UASR: Unified Approach to Speech Synthesis and Recognition
## - Data packaging tool for dLabPro recognizer
##
## AUTHOR : Frank Duckhorn, Matthias Wolff
## PACKAGE: uasr/scripts/dlabpro/tools
##
## ARGUMENTS:
##   $1: Command or 'help'
##   $2: Configuration file or, if 1st arg. is 'help', command

## Copyright 2013-2016 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus-Senftenberg
## - Fraunhofer IKTS, Dresden
## - Chair of System Theory and Speech Technology, TU Dresden
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"../util/cfg.itp"  include;
"../util/fst.itp"  include;
"../util/lab.itp"  include;
"../util/lm.itp"   include;
"../util/lx.itp"   include;
"../util/os.itp"   include;
"../util/par.itp"  include;
"../util/uasr.itp" include;
"../util/var.itp"  include;
"../util/fea.itp"  include;
"../util/sig.itp"  include;
"include/recpack_ssmg/base.itp"     include;
"include/recpack_ssmg/fba.itp"      include;
"include/recpack_ssmg/mel.itp"      include;
"include/recpack_ssmg/pca.itp"      include;
"include/recpack_ssmg/mahala.itp"   include;
"include/recpack_ssmg/gmm.itp"      include;
"include/recpack_ssmg/recodata.itp" include;
"include/recpack_ssmg/dialog.itp"   include;
"include/recpack_ssmg/syn.itp"      include;
"include/recpack_ssmg/keytab.itp"   include;
"include/recpack_recfix/maxdim.itp" include;
"include/recpack_recfix/base.itp"   include;
"include/recpack_recfix/sig.itp"    include;
"include/recpack_recfix/pfa.itp"    include;
"include/recpack_recfix/sfa.itp"    include;
"include/recpack_recfix/gmm.itp"    include;
"include/recpack_recfix/fst.itp"    include;
"include/recpack_recfix/trg.itp"    include;
"include/recpack_recfix/syn.itp"    include;
"include/recpack_recfix/wom.itp"    include;

## Prints help on usage
function -usage(sCmd)
{
  sCmd "dlg" == if
    "\n\n   SYNOPSIS:"                                                    -MSG;
      "\n     Pack recognition data (dialog)"                             -MSG;
    "\n\n   USAGE:"                                                       -MSG;
      "\n     dlabpro $__SFILE__.xtp $[sCmd] <cfgfile> [options]"         -MSG;
    "\n\n   ARGUMENTS:"                                                   -MSG;
      "\n     <cfgfile>       UASR config. file of the HMM training that" -MSG;
      "\n                     was used to create the phoneme models"      -MSG;
    "\n\n   OPTIONS:"                                                     -MSG;
      "\n     -c              use colors for screen protocol"             -MSG;
      "\n     -n              do not write any files"                     -MSG;
      "\n     -v<n>           verbose level (-v0: silent mode)"           -MSG;
      "\n     -P<key>=<value> override config. key-value-pairs"           -MSG;
    "\n\n   REMARKS:"                                                     -MSG;
      "\n     Special <key>s for $__SFILE__.xtp:"                         -MSG;
      "\n       dlg.fsg       finite state dialog file"                   -MSG;
      "\n       export        One of the following (default: none)"       -MSG;
      "\n                       openFST - export openFST grammar files"   -MSG;
      "\n       outtyp        output type (default: R)"                   -MSG;
      "\n                       R - files for recognizer"                 -MSG;
      "\n                       S - files for ssmg demonstrator"          -MSG;
      "\n                       F - file for recfix"                      -MSG;
      "\n       out           output folder (default: current folder)"    -MSG;
      "\n       out.feainfo   output file (default: <out>/feainfo.object)"-MSG; 
      "\n       out.gmm       output file (default: <out>/<am.model>.gmm)"-MSG; 
      "\n       out.sesinfo   output file (default: <out>/sesinfo.object)"-MSG; 
      "\n       vad.model     VAD file name (default: <out>/3_10_mod.vad)"-MSG;
      "\n       gmm.mix       Create mixtures (default: yes)"             -MSG;
      "\n       syn.dir       Synthesis directory (default: <out>/syn)"   -MSG;
      "\n       syn.model     Synthesis model (default: 3_20)"            -MSG;
      "\n       render        yes/no: render dialog and grammar FSTs "    -MSG;
                              "(default: no)"                             -MSG;
      "\n       skip          Combination of the following letters"       -MSG;
      "\n                       F - skip creating feature info file"      -MSG;
      "\n                       G - skip creating GMM file"               -MSG;
      "\n                       S - skip creating session info file"      -MSG;
      "\n     Important common <key>s for $__SFILE__.xtp:"                -MSG;
      "\n       am.model      acoustic model (HMM) ID"                    -MSG;
    "\n\n   EXAMPLES:"                                                    -MSG;
      "\n     $__SFILE__.xtp $[sCmd] VMX.cfg -Pam.model=3_10 "
              "-Pdlg.fsg=mydialog.dlg.txt -Pout=myfolder"               + -MSG;
      "\n"                                                                -MSG;
    leave;
  end
  sCmd "rec" == if
    "\n\n   SYNOPSIS:"                                                    -MSG;
      "\n     Pack recognition data (simple grammar)"                     -MSG;
    "\n\n   USAGE:"                                                       -MSG;
      "\n     dlabpro $__SFILE__.xtp $[sCmd] <cfgfile> [options]"         -MSG;
    "\n\n   ARGUMENTS:"                                                   -MSG;
      "\n     <cfgfile>       UASR config. file of the HMM training that" -MSG;
      "\n                     was used to create the phoneme models"      -MSG;
    "\n\n   OPTIONS:"                                                     -MSG;
      "\n     -c              use colors for screen protocol"             -MSG;
      "\n     -n              do not write any files"                     -MSG;
      "\n     -v<n>           verbose level (-v0: silent mode)"           -MSG;
      "\n     -P<key>=<value> override config. key-value-pairs"           -MSG;
    "\n\n   REMARKS:"                                                     -MSG;
      "\n     Special <key>s for $__SFILE__.xtp:"                         -MSG;
      "\n       export        One of the following (default: no)"         -MSG;
      "\n                       openFST - export openFST grammar files"   -MSG;
      "\n       outtyp        output type (default: R)"                   -MSG;
      "\n                       R - files for recognizer"                 -MSG;
      "\n                       S - files for ssmg demonstrator"          -MSG;
      "\n                       F - file for recfix"                      -MSG;
      "\n       out           output folder (default: current folder)"    -MSG;
      "\n       out.feainfo   output file (default: <out>/feainfo.object)"-MSG; 
      "\n       out.gmm       output file (default: <out>/<am.model>.gmm)"-MSG; 
      "\n       out.sesinfo   output file (default: <out>/sesinfo.object)"-MSG; 
      "\n       vad.model     VAD file name (default: <out>/3_10_mod.vad)"-MSG;
      "\n       gmm.mix       Create mixtures (default: yes)"             -MSG;
      "\n       syn.dir       Synthesis directory (default: <out>/syn)"   -MSG;
      "\n       syn.model     Synthesis model (default: 3_20)"            -MSG;
      "\n       recfix.prnw   Weight pruing threshold (default: 0)"       -MSG; 
      "\n       render        yes/no: render dialog and grammar FSTs "    -MSG;
                              "(default: no)"                             -MSG;
      "\n       skip          Combination of the following letters"       -MSG;
      "\n                       F - skip creating feature info file"      -MSG;
      "\n                       G - skip creating GMM file"               -MSG;
      "\n                       S - skip creating session info file"      -MSG;
      "\n     Important common <key>s for $__SFILE__.xtp:"                -MSG;
      "\n       am.model      acoustic model (HMM) ID"                    -MSG;
      "\n       lm.fsg        finite state grammar file (default: none)"  -MSG;
    "\n\n   EXAMPLES:"                                                    -MSG;
      "\n     $__SFILE__.xtp $[sCmd] VMX.cfg -Pout=myfolder"              -MSG;
      "\n     $__SFILE__.xtp $[sCmd] VMX.cfg -Pam.model=3_10 "
              "-Plm.fsg=mygrammar.grm.txt -Pout=myfolder"               + -MSG;
    TRUE .__CFG_bCol =;
    "$3" "-Pouttyp=F" != if;
      "\n\n  Type 'dlabpro $__SFILE__.xtp help rec -Pouttyp=F' for help on"
             " recfix normalization factor config\n" + -COLOR_note        -MSG;
    else;
      "\n\n   Normalization factor config for recfix:"                    -MSG;
      "\n      Normalization factors (recfix.frm.*!=0) overwrite "
              "automatically calculated ones (displayed with -v2)." +     -MSG;
      "\n       recfix.nrm.frm  Factor after framing        (default: 0)" -MSG;
      "\n       recfix.nrm.trf  Factor after transformation (default: 0)" -MSG;
      "\n       recfix.nrm.fil  Factor after filter         (default: 0)" -MSG;
      "\n       recfix.nrm.dlt0 Factor for 1. delta comp.   (default: 0)" -MSG;
      "\n       recfix.nrm.dlt1 Factor for 2. delta comp.   (default: 0)" -MSG;
      "\n       recfix.nrm.dlt2 Factor for 3. delta comp.   (default: 0)" -MSG;
      "\n       recfix.nrm.dlt3 Factor for 4. delta comp.   (default: 0)" -MSG;
      "\n       recfix.nrm.pca  Factor after PCA            (default: 0)" -MSG;
      "\n      Right shifts in operation are used to prevent overflows."  -MSG;
      "\n      They are compensated by shifting config values."           -MSG;
      "\n      They do not change normalization."                         -MSG;
      "\n       recfix.shf.fil  Shift in filter            (default: 0)"  -MSG;
      "\n       recfix.shf.dlt0 Shift for 1. delta comp.   (default: 3)"  -MSG;
      "\n       recfix.shf.dlt1 Shift for 2. delta comp.   (default: 3)"  -MSG;
      "\n       recfix.shf.dlt2 Shift for 3. delta comp.   (default: 3)"  -MSG;
      "\n       recfix.shf.pca  Shift in PCA               (default: 3)"  -MSG;
      "\n      Trigger configuration."                                    -MSG;
      "\n       recfix.trg.mode Trigger mode (see nTRGM_* in maxdim.itp)" -MSG;
      "\n       recfix.trg.thr1 Activation threshold       (default: 0.3)"-MSG;
      "\n       recfix.trg.thr2 Deactivation threshold     (default: 0.2)"-MSG;
      "\n       recfix.trg.off1 Activation offset          (default: -6)" -MSG;
      "\n       recfix.trg.off2 Deactivation offset        (default: 6)"  -MSG;
      "\n       recfix.trg.mino Minimal deactivation time  (default: 30)" -MSG;
      "\n       recfix.trg.lda  Use this trained lda trigger model"       -MSG;
      "\n      Confidence configuration."                                 -MSG;
      "\n       recfix.cnf.mode Confid. mode (see nCNFM_* in maxdim.itp)" -MSG;
      "\n       recfix.cnf.tad  Threshold for acoustic distance"          -MSG;
      "\n       recfix.cnf.ted  Threshold for edit distance"              -MSG;
      "\n"                                                                -MSG;
    end;
    leave;
  end
  sCmd "vad" == if
    "\n\n   SYNOPSIS:"                                                    -MSG;
      "\n     Pack voice activity detection data"                         -MSG;
    "\n\n   USAGE:"                                                       -MSG;
      "\n     dlabpro $__SFILE__.xtp $[sCmd] <cfgfile> [options]"         -MSG;
    "\n\n   ARGUMENTS:"                                                   -MSG;
      "\n     <cfgfile>       UASR config. file of the HMM training that" -MSG;
      "\n                     was used to create the VAD models"          -MSG;
    "\n\n   OPTIONS:"                                                     -MSG;
      "\n     -c              use colors for screen protocol"             -MSG;
      "\n     -n              do not write any files"                     -MSG;
      "\n     -v<n>           verbose level (-v0: silent mode)"           -MSG;
      "\n     -P<key>=<value> override config. key-value-pairs"           -MSG;
    "\n\n   REMARKS:"                                                     -MSG;
      "\n     Special <key>s for $__SFILE__.xtp:"                         -MSG;
      "\n       out           output folder (default: current folder)"    -MSG;
      "\n       out.vad       output file (default: <out>/<am.model>.vad)"-MSG; 
      "\n"                                                                -MSG;
    leave;
  end
  sCmd "xtpx" == if
    "\n\n   SYNOPSIS:"                                                    -MSG;
      "\n     Create $__SFILE__.xtpx self-contained program archive"      -MSG;
    "\n\n   USAGE:"                                                       -MSG;
      "\n     dlabpro $__SFILE__.xtp $[sCmd]"                             -MSG;
    "\n\n   REMARKS:"                                                     -MSG;
      "\n     Archive can be used lust like $__SFILE__.xtp itself:"       -MSG;
      "\n       dlabpro $__SFILE__.xtpx <command> <cfgfile> [options]"    -MSG;
      "\n"                                                                -MSG;
    leave;
  end
  "\n\n   SYNOPSIS:"                                                      -MSG;
    "\n     Data packaging tool for the dLabPro speech recognizer"        -MSG;
  "\n\n     The recognizer requires data files to operate. You must"      -MSG;   
    "\n     create GMM and grammar files (command 'rec') AND a voice"     -MSG;   
    "\n     activity detection info file (command 'vad')."                -MSG;   
  "\n\n   USAGE:"                                                         -MSG;
    "\n     dlabpro $__SFILE__.xtp <command> <cfgfile> [options]"         -MSG;
  "\n\n   COMMANDS:"                                                      -MSG;
    "\n     dlg  - Pack recognition data (dialog)"                        -MSG;
    "\n     rec  - Pack recognition data (simple grammar)"                -MSG;
    "\n     vad  - Pack voice activity detection data"                    -MSG;
    "\n     xtpx - Create $__SFILE__.xtpx program archive"                -MSG;
  "\n\n  Type 'dlabpro $__SFILE__.xtp help <command>' for help on a "     -MSG;
         "specific command.\n"                                            -MSG;
}

## Checks if the specified file exists and echoes a message.
##
## @param sFile string
##          the file name
## @param sMsg string
##          a string indicating the file type
## @return <code>TRUE</code> if the file exists or is not idicated as required,
##         <code>FALSE</code> otherwise
function -FCHK(sFile,sMsg,bRequired)
{
  "\n   - " ( sMsg -14 -MSG_pad ) + ": "                                + -MSG; # Protocol
  sFile not if                                                                  # No or empty file name >>
    bRequired if                                                                #   File ist required >>
      "NOT SPECIFIED" -COLOR_red                                          -MSG; #     Protocol
      FALSE return;                                                             #     Not good
    else                                                                        #   << File is not required >>
      "not specified" -COLOR_yellow " (acceptable)"                     + -MSG; #     Protocol
      TRUE return;                                                              #     Acceptable
    end                                                                         #   <<
  end                                                                           # <<
  "$[sFile] ("                                                            -MSG; # Protocol
  sFile stdfile -exists if                                                      # File exist
    "exists)" -MSG;                                                             #   Tell it
    TRUE return;                                                                #   Very good
  end                                                                           # << (file does not exist)
  "NOT FOUND" -COLOR_red ")" + -MSG;                                            # Tell it
  FALSE return;                                ´                                # Not good
}

## Checks if the finite state grammer file exists and prints a message. If no
## finite state grammar was specified through &lt;uasr.lm.fsg&gt;, i.e. if the
## global variable <code>.sFsgFile</code> is <code>NULL</code>, the function
## creates a default grammar file in the log folder an changes 
## <code>.sFsgFile</code> to the newly created file. 
function -FFSG()
{
  "\n   - " ( "Grammar" -14 -MSG_pad ) + ": "                           + -MSG; # Protocol
  .sFsgFile not if                                                              # No or empty file name >>
    "not specified" -COLOR_yellow " (acceptable, using built-in)"       + -MSG; #   Protocol
    DGen iDG;                                                                   #   Document generator
    hmm itHMM;                                                                  #   HMMs
    var sDirLog;  ( "log" "S" -CFG_get_path )    sDirLog  =;                    #   Get log folder
    var sFsgFile; "$__SFILE__.grm.txt"           sFsgFile =;                    #   Make grammar file name
    var nMidPau;  ( "am.sil" 3 "S" -CFG_get_ex ) nMidPau  -vset;                #   Get pause model ID
    var nMidGbg;  ( "am.gbg" 4 "S" -CFG_get_ex ) nMidGbg  -vset;                #   Get garbage model ID
    var i;                                                                      #   Loop counter
    ( sDirLog "/" + sFsgFile + ) .sFsgFile =;                                   #   Make grammar file path name
    "\n     - Reading \"$[.sAmFile]\" ..."                                -MSG; #   Protocol
    .sAmFile itHMM /noerror -restore                                            #   Read acoustic model file
    ?error if " FAILED" -COLOR_red -MSG; FALSE return; end " ok" -MSG;          #   Check for errors
    "\#\# UASR Finite State Grammar File\n"                             iDG >>; #   Write to document
    "\#\# - This file was generated by $__SFILE__.xtp\n\n"              iDG >>; #   Write to document
    nMidPau 0 >= if                                                             #   Have pause model >>
      "GRM: (S) <PAU> (S)\n"                                            iDG >>; #     Add leading pause
      "GRM: (F) <PAU> (F)\n"                                            iDG >>; #     Add tailing pause
    end                                                                         #   <<
    0 i =; i itHMM.ud.nrec < while                                              #   Loop over models >>
      "GRM: S  _${itHMM.ud[i,0]}:${itHMM.ud[i,0]}\n"                    iDG >>; #     Write grammar rule
      i ++=;                                                                    #     Next model
    end                                                                         #   <<
    0 i =; i itHMM.ud.nrec < while                                              #   Loop over models >>
      "LEX: _${itHMM.ud[i,0]} ${itHMM.ud[i,0]}\n"                       iDG >>; #     Write lexicon entry
      i ++=;                                                                    #     Next model
    end                                                                         #   <<
    "\n\#\# EOF\n"                                                      iDG >>; #   Write to document
    "\n     - Writing \"$[.sFsgFile]\" ..."                               -MSG; #   Protocol
    .__CFG_bNwr not if                                                          #   Not write-protected >>
      .sFsgFile iDG /noerror -write                                             #     Write grammar file
      ?error if " FAILED" -COLOR_red -MSG; FALSE return; end " ok" -MSG;        #     Check for errors
    else                                                                        #   << Write protected >>
      " SKIPPED (write protection on!)" -COLOR_yellow                     -MSG; #     Protocol
    end                                                                         #   <<
    TRUE return;                                                                #   Ok
  end                                                                           # <<
  "$[.sFsgFile] ("                                                        -MSG; # Protocol
  .sFsgFile stdfile -exists if                                                  # File exist
    "exists)" -MSG;                                                             #   Tell it
    TRUE return;                                                                #   Very good
  end                                                                           # << (file does not exist)
  "NOT FOUND" -COLOR_red ")" + -MSG;                                            # Tell it
  FALSE return;                                ´                                # Not good
}

## EXPERIMENTAL: Guesses the terminal input symols from grammer rules.
##
## @param idRules data
##          The rule set (as obtained by <code>-FSG_load</code>).
## @param idTrmTab data
##          Filled with the list of terminal input symbols.
## @return void 
function -FSG_get_trm_tab(idRules,idTrmTab)
{
  data idAux;                                                                   # Auxiliary data instance
  idRules 0 1 idTrmTab -delete;                                                 # Remove left side of rules
  idTrmTab ${idTrmTab.dim*idTrmTab.nrec} 1 idTrmTab -reshape;                   # Get all symbols in one component
  idTrmTab "(" "search" idAux -strop; :idAux[0].==0: idTrmTab -dmark;           # Mark symbols starting with "("
  idTrmTab 0 0 idTrmTab /mark -delete;                                          # Delete marked symbols
  idTrmTab ":" "split" idTrmTab -strop;                                         # Remove all from first ":" on
  idTrmTab 0 idTrmTab -sortup;                                                  # Sort symbol table
  idTrmTab 0 idTrmTab -compress; idTrmTab 0 1 idTrmTab -select;                 # Compress
}

## EXPERIMENTAL: Loads a finite state dialog model from a file.
##
## @param sFile string
##          The path of text file to be loaded.
## @param sFilter string
##          The line filter (consider only lines starting with the given string),
##          use "" to read all lines.
## @param itDlg fst
##          Filled with the dialog FST.
## @return <code>TRUE</code> if successful, <code>FALSE</code> otherwise.
function -FSG_load_dialog(sFile,sFilter,itDlg)
{
  data idRules;                                                                 # The rule set
  data idTrmTab;                                                                # The table of terminal input symbols
  sFile sFilter idRules -FSG_load not if FALSE return; end                      # Load rule set
  idRules idTrmTab -FSG_get_trm_tab;                                            # Guess terminal input symols
  idRules idTrmTab NULL itDlg -FSG_compile;                                     # Compile dialog FST
  itDlg.td ( "~LSR" itDlg.td -find_comp ) 1 itDlg.td -delete;                   # Remove weights
  0 1 itDlg.sd -mark; 1 0 itDlg.sd /mark -fill; itDlg.sd -unmark;               # Make all states final
  0 0 itDlg -trim;                                                              # Remove unused states
  .bRender if                                                                   # Rendering grammar? Yes >>
    var s; "$[.sDirOut]/" ( sFilter "#:#.svg" "replace" -VAR_strop ) + s =;     #   Make file name
    s itDlg.is itDlg.os -1 itDlg -FST_render;                        "." -MSG2; #   Protocol
  end                                                                           # <<
  TRUE return;
}

## Normalizes the output symbols of a finite state grammar. "Normalizing" means
## that opening and closing square brackets, '[' and ']', will be placed at 
## separate transitions. For example, the function will replace the transition
## &#x25EF;&mdash;"[foo["&rarr;&#x25EF; by the chain 
## &#x25EF;&mdash;"["&rarr;&#x25EF;&mdash;"foo"&rarr;&#x25EF;&mdash;"["&rarr;&#x25EF;.
##
## @param itLMsrc fst
##          A finite state grammar.
## @param itLMdst fst
##          The normalized finite state grammar, may be indentical with 
##          <code>itLM</code>.
## @return The edit transducer used to normalize the grammar.
function -FSG_normalize(itLMsrc,itLMdst)
{
  function -add_symbols(idSym,idTab)                                            # Add symbols to transducer symbol tab.
  {                                                                             # >>
    data idAux;                                                                 #   Auxiliary data
    idSym idTab 0 0 idAux /noerror -gen_index;                                  #   Find symbols that already exist
    idSym idAux -join;                                                          #   ...
    :idAux[0].>=0: idAux /comp -dmark; idAux 0 0 idAux /mark -delete;           #   Mark and delete them
    idAux.nrec 0 == if return; end                                              #   No new symbols -> leave
    idAux 1 idAux -sortup; idAux 1 idAux -compress;                             #   Remove duplicate new symbols
    :idAux[0]: idTab -cat;                                                      #   Add new symbols
  }                                                                             # <<

  function -add_edit(sTos,itE)                                                  # Add one edit to edit transducer
  {                                                                             # >>
    data idTis; { "$[sTos]" } idTis =;                                          #   Editor input symbol
    data idTos;                                                                 #   Editor output sequence
    data idAux;                                                                 #   Auxiliary data
    var  nFT;                                                                   #   First transition of new edit
    
    idTis "[]" "splitd" idTos -strop; idTos ' idTos =;                          #   Split input symb.into output symbs.
    idTos itE.is -add_symbols;                                                  #   Add 'em output symbols
    idTos itE.is 0 0 idAux -gen_index; idAux idTos -join;                       #   Look-up output symbol indices

    itE.td.nrec nFT =;                                                          #   Remember index of first new trans.
    "$[sTos]" itE /fst /lsr -addunit;                                           #   Create new edit
    idTos 1 -1 -1 :itE.ud.nrec-1: itE -addseq;                                  #   Add editor output sequence
    idTis itE.os 0 0 idAux -gen_index;                                          #   Get index if edited input symbol
    :itE.td[nFT,itE.NC_TD_TOS]=idAux[0,0];                                      #   Add edited symbol to first trans.
  }                                                                             # <<

  fst itLMn;                                                                    # Normalize grammar
  fst itE;                                                                      # Edit transducer
  var nTos;                                                                     # Output symbol index
  var sTos;                                                                     # Output symbol
  itLMsrc.os itE.os =;                                                          # Initialize input symbol table  
  { "[" "]" } ' itE.is =;                                                       # Initialize output symbol table  
  0 nTos =; nTos itLMsrc.os.nrec < while                                        # Loop over output symbols >>
    :itLMsrc.os[nTos,0]: sTos =;                                                #   Get output symbol
    sTos itE -add_edit;                                                         #   Add edit transducer path
    nTos ++=;                                                                   #   Next output symbol
  end                                                                           # <<
  itE itE -union;                                                               # Union of edits
  0 itE -invert;                                                                # Inversion
  itE 0 itE -close;                                                             # Kleene closure

  # TODO: Better replace instead of compose (would mak smaller network)!
  itE.sd.nrec 1 > if                                                            # Editor has more than one state >>
    itLMsrc itE 0 0 itLMdst -compose;                                           #   Normalize grammar
  end                                                                           # << (otherwise no normalizatn.needed)
  
  itE return;                                                                   # Return edit transducer
}

## Adds a unit to the recognition network
##
## @param sFile string
##          The path of text file to be loaded.
## @param sFilter string
##          The line filter (consider only lines starting with the given string),
##          use "" to read all lines.
## @param iSI object
##          The pre-initialized session info object to continue. The function
##          relies on the following fields:
##          <ul>
##            <li><code>iSI.itLX</code> (lexicon FST)</li>
##            <li><code>iSI.itRNr</code> (reference recognition network)</li>
##          </ul>
function -RN_add_unit(sFile,sFilter,iSI)
{
  fst  itAM;                                                                    # The HMAs (union and closed)
  fst  itLX;                                                                    # The lexicon FST
  fst  itLM;                                                                    # The grammar FST
  fst  itRN;                                                                    # The recognition network
  fst  itAux;                                                                   # Auxiliary FST
  data idFsg;                                                                   # The grammar rule set
  data idFsg2;                                                                  # The common grammar rule set
  var  s; 

  "\n   - Loading grammar from \"$[.sFsgFile]\" [$[sFilter]] ..."        -MSG2; # Protocol
  sFile sFilter idFsg -FSG_load                                                 # Load grammar rules
  not if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."        -MSG; # Check for errors
  sFilter "GRM:" != if                                                          # Not loading the common grammar >>
    "\n   - Loading common grammar from \"$[.sFsgFile]\" [GRM:] ..."     -MSG2; #   Protocol
    sFile "GRM:" idFsg2 -FSG_load                                               #   Load grammar rules
    not if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2;                #   Check for errors
    idFsg2.dim idFsg.dim > if                                                   #   Concatenate rule sets
      idFsg idFsg2 -cat; idFsg2 idFsg -copy;                                    #   ...
    else                                                                        #   ...
      idFsg2 idFsg -cat;                                                        #   ...
    end                                                               "." -MSG; #   ...
  end                                                                           # <<

  "\n   - Compiling grammar ."                                           -MSG2; # Protocol
  1 .__UTL_nElevel =;                                                           # Switch unused rules warnings off
  idFsg iSI.itLX.os NULL itLM -FSG_compile;                          "." -MSG2; # Compile grammar (string -> FST)
  #itLM -1 itLM /lazy -minimize;                                                # Lazily minimize
  #itLM.sd ( "~NAM" itLM.sd -find_comp ) 1 itLM.sd -delete;                      # Remove state names
  .bExpOfst if                                                                  # Export openFST? Yes >>
    "$[.sDirOut]/" ( sFilter "#:#.txt" "replace" -VAR_strop ) + s =;            #   Make file name
    "\n   - Writing \"$[s]\" ..."                                        -MSG2; #   Protocol
    s "fsm-t" itLM stdfile /noerror -export                                     #   Export openFST
    ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."   -MSG; #   Check for errors
  end                                                                           # <<
  .bRender if                                                                   # Rendering grammar? Yes >>
    "$[.sDirOut]/" ( sFilter "#:#.svg" "replace" -VAR_strop ) + s =;            #   Make file name
    "\n   - Writing \"$[s]\" ..."                                        -MSG2; #   Protocol
    s itLM.is itLM.os -1 itLM -FST_render;                           "." -MSG2; #   Protocol
  end                                                                           # <<
  ( itLM itLM -FSG_normalize ) itAux =;                              "." -MSG2; # Normalize FVR output symbols
  itLM 0 itLM /lazy -minimize;
  .bRender if                                                                   # Rendering grammar? Yes >>
    "$[.sDirOut]/" ( sFilter "#:#.normalized.svg" "replace" -VAR_strop ) + s =; #   Make file name
    "\n   - Writing \"$[s]\" ..."                                        -MSG2; #   Protocol
    s itLM.is itLM.os -1 itLM -FST_render;                           "." -MSG2; #   Protocol
    "$[.sDirOut]/" ( sFilter "#:#.normalizer.svg" "replace" -VAR_strop ) + s =; #   Make file name
    "\n   - Writing \"$[s]\" ..."                                        -MSG2; #   Protocol
    s itAux.is itAux.os -1 itAux -FST_render;                        "." -MSG2; #   Protocol
    "\n   - Check square bracket parity of output language ..."          -MSG2; #   Protocol
    fst itCheck;                                                                #   Check error path
    ( itLM itCheck fvrtools -fsg_fvr_check ) not if                             #   Check output symb. brace parity >>
      " FAILED" -COLOR_red                                               -MSG2; #      Protocol
      "$[.sDirOut]/" ( sFilter "#:#_ErrDetect.svg" "replace" -VAR_strop ) + s =;#      Make file name
      s itCheck.is itCheck.os -1 itCheck -FST_render;                "." -MSG2; #      Protocol
    else                                                                        #      is check correct?
      " ok"                                                              -MSG2; #      Protocol
    end                                                                         #   <<
    #"GRM.fst" itLM -save                                                       #   save grammer extra
  end                                                                           # <<

  "\n   - Compiling word recognition network "                           -MSG2; # Protocol
  iSI.itLX itLX -LX_unify;                                                      # Kleene-closure of lexicon FST
  iSI.itRNr itAM -copy;                                                         # Get phoneme loop
  0 0 0 itAM -addtrans { -1 -1 0 };                                             # Prepare HMAs for composition
  0 itLX /noerror -loops { -1 -1 0 };                                "." -MSG2; # Prepare lex for composition
  itAM itLX 0 0 itAux /noeps /noint -compose;                        "." -MSG2; # Compose: hma o lex
  itAux 0 itAux /lazy -minimize;                                                # Minimize and
  itAux 0 itAux -close;                                                         # Close (hma o lex)

  "\n   - Compiling recognition network "                                -MSG2; # Protocol
  0 0 0 itAux -addtrans { -1 -1 0 };                                            # Prepare (hma o lex) for composition
  0 itLM /noerror -loops { -1 -1 0 };                                "." -MSG2; # Prepare grammar for composition
  itAux itLM 0 0 itRN /noeps /noint -compose;                        "." -MSG2; # Compose: (hma o lex) o grm
  itRN 0 itRN /lazy -minimize;                                       "." -MSG2; # Minimize result ->recognition network

  "~STK" itRN.td -find_comp 0 < if                                              # No stack token component >>
    "~STK" ( 2 itRN.td -get_comp_type ) itRN.td -addcomp;                       #   Add comp. (of input symbol type)
  end                                                                           # <<
  :itRN.td["~TOS"]=itRN.td["~TOS"]+((itRN.td["~TOS"].>=0)*iSI.itRN.os.nrec);    # Adjust non-epsilon output symbols
  itRN.os iSI.itRN.os -cat;                                                     # Append output symbol table
  itRN iSI.itRN -cat;                                                           # Append to recognition network
  " done (${itRN.sd.nrec} states, ${itRN.td.nrec} transitions)" -MSG2 "." -MSG; # Protocol
}

## Packs the feature info file.
function -PACK_feainfo(retFI)
{
  object iFI;                                                                   # The feature info object
  var    sOutFile; "$[.sDirOut]/feainfo.object" sOutFile =;                     # Get default output file name
  ( "out.feainfo" sOutFile "S" -CFG_get_ex )    sOutFile =;                     # Get configured output file name
  "\n   Packing feature info file ."                                      -MSG; # Protocol
  "\n   - Reading \"$[.sFiFile]\" ..."                                   -MSG2; # Protocol
  .sFiFile iFI /noerror -restore                                                # Read feature info file
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors
  retFI NULL != if; iFI retFI =; 1 return; end;                                 # Return feature info object
  "\n   - Writing \"$[sOutFile]\" ..."                                   -MSG2; # Protocol
  .__CFG_bNwr not if                                                            # Not write-protected >>
    sOutFile iFI /noerror /zip -save                                            #   Save feature info file
    ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."   -MSG; #   Check for errors
  else                                                                          # << Write protected >>
    " SKIPPED (write protection on!)" -COLOR_yellow                      -MSG2; #   Protocol
  end "\n  " -MSG2; " ok" -MSG;                                                 # <<
  1 return;                                                                     # All right
}

## Packs the acoustic model file.
function -PACK_gmm(retGm)
{
  hmm  itHMM;                                                                   # The HMM
  gmm  itGm;
  data idM;
  data idC;
  vmap iVM;
  var  sOutFile; "$[.sDirOut]/$[.sAm].gmm" sOutFile =;                          # Get default output file name
  ( "out.gmm" sOutFile "S" -CFG_get_ex )   sOutFile =;                          # Get configured output file name
  ( "gmm.mix" "yes" "S" -CFG_get_ex ) "yes" == var bGmmMix;                     # Get mixture creation flag

  "\n   Packing Gaussian mixture model file ."                            -MSG; # Protocol
  "\n   - Reading \"$[.sAmFile]\" ..."                                   -MSG2; # Protocol
  .sAmFile itHMM /noerror -restore                                              # Read acoustic model file
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors

  "\n   - Extracting Gaussian mixture models ..."                        -MSG2; # Protocol
  bGmmMix itHMM.gm.mmap NULL == && if itHMM -gmm_mix end;                       # Create mixtures
  itHMM.os -is_empty if :itHMM.ud["~NAM"]: itHMM.os = end;                      # Check/create HMM name table
  idM idC itHMM.gm -extract;                                                    # Get mean vectors and covariance matrizes
  itHMM.gm.mmap NULL == if;                                                     # Setup without mixture map >>
    idM idC NULL itGm /float /icov -setup;                                      #   Setup Gaussians
  else;                                                                         # << Setup with mixture map >>
    itHMM.gm.mmap.tmx "lsadd" "add" INF iVM /float -setup;                      #   Setup maping object
    idM idC iVM itGm /float /icov -setup;                                       #   Setup Gaussians
  end;                                                                          # <<
  " done" -MSG2 "."                                                       -MSG; # Protocol

  retGm NULL != if; itGm retGm =; 1 return; end;                                # Return gaussian mixture model
  "\n   - Writing \"$[sOutFile]\" ..."                                   -MSG2; # Protocol
  .__CFG_bNwr not if                                                            # Not write-protected >>
    sOutFile itGm /noerror /zip -save                                           #   Save GMM file
    ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."   -MSG; #   Check for errors
  else                                                                          # << Write protected >>
    " SKIPPED (write protection on!)" -COLOR_yellow                      -MSG2; #   Protocol
  end "\n  " -MSG2; " ok" -MSG;                                                 # <<
  1 return;                                                                     # All right
}

## Packs the acoustic model file. [CURRENTLY NOT USED]
function -PACK_hmm(retHMM)
{
  hmm itHMM;                                                                    # The HMM
  var sOutFile; "$[.sDirOut]/$[.sAm].hmm" sOutFile =;                           # Get default output file name
  ( "out.hmm" sOutFile "S" -CFG_get_ex )  sOutFile =;                           # Get configured output file name
  "\n   Packing acoustic model file ."                                    -MSG; # Protocol
  "\n   - Reading \"$[.sAmFile]\" ..."                                   -MSG2; # Protocol
  .sAmFile itHMM /noerror -restore                                              # Read acoustic model file
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors
  retHMM NULL != if; itHMM retHMM =; 1 return; end;                             # Return HMM
  "\n   - Writing \"$[sOutFile]\" ..."                                   -MSG2; # Protocol
  .__CFG_bNwr not if                                                            # Not write-protected >>
    sOutFile itHMM /noerror /zip -save                                          #   Save acoustic model file
    ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."   -MSG; #   Check for errors
  else                                                                          # << Write protected >>
    " SKIPPED (write protection on!)" -COLOR_yellow                      -MSG2; #   Protocol
  end "\n  " -MSG2; " ok" -MSG;                                                 # <<
  1 return;                                                                     # All right
}

## Packs the session info file.
##
## <a name="index:iSI" title="Session information object"></a>
## <p>The session information object is structured as follows:</p>
## <table class="indent" cellpadding="0" cellspacing="0" border="0">
##   <tr>
##     <th><code><b>iSI</b></code></th>
##     <th>Description</th>
##   </tr>
##   <tr>
##     <td class="hidden"><nobr>&nbsp;<img class="jttIcon" src="../../resources/jtt04l.gif">
##       <code>idLMtos</code></nobr></td>
##     <td class="hidden"><i>&ndash; deprecated &ndash;</i> The output symbols of the
##       recognition network, to be replaced by <code>itRN.os</code>.</td>
##   </tr>
##   <tr>
##     <td class="hidden"><nobr>&nbsp;<img class="jttIcon" src="../../resources/jtt04l.gif">
##       <code>itGP</code></nobr></td>
##     <td class="hidden">The Gaussian-to-phoneme labelling transducer. Used by the recognizer
##       to generate phonetic output strings. For general acoustic pattern recognition
##       applications read "HMM labels" instead of "phonemes".</td>
##   </tr>
##   <tr>
##     <td class="hidden"><nobr>&nbsp;<img class="jttIcon" src="../../resources/jtt04l.gif">
##       <code>itLX</code></nobr></td>
##     <td class="hidden">The lexicon (phoneme-to-word) transducer. The object contains exactly
##       one <a href="javascript:__goDlabpro('automatic/fst.html','mth_-addunit')">FST unit</a>
##       per lexicon entry. For general acoustic pattern recognition tasks the "lexicon" consists
##       of application specific re-occurring HMM label sequences.</td>
##   </tr>
##   <tr>
##     <td class="hidden"><nobr>&nbsp;<img class="jttIcon" src="../../resources/jtt04l.gif">
##       <code>itRN</code></nobr></td>
##     <td class="hidden">The recognition network translating between Gassian sequences and
##       grammar output symbol strings.</td>
##   </tr>
##   <tr>
##     <td class="hidden"><nobr>&nbsp;<img class="jttIcon" src="../../resources/jtt03l.gif">
##       <code>itRNr</code></nobr></td>
##     <td class="hidden">The reference recognition network translating between Gaussian
##       sequences and phoneme strings. The object is used to obtain a secondary, unconstrained
##       decoding for measuring the recognition confidence. For general acoustic pattern recognition
##       applications read "HMM labels" instead of "phonemes". The object is only needed if a
##       reference decoding is performed, otherwise it may be omitted.</td>
##   </tr>
## </table>
function -PACK_sesinfo(retSI,retDlg)
{
  function -unify_symbols(idSymRef,idTd,sComp,idSymDst)
  {
    data idAux;

    # Unify symbol tables                                                       #   ---------------------------
    idSymDst idSymRef 0 0 idAux /noerror -gen_index;                            #   Find missing symbols in idSymRef
    :idAux.<0: idSymDst -dmark; idSymDst 0 0 idAux /mark -select;               #   |
    idAux idSymRef -cat;                                                        #   Add symbols to idSymRef

    # Map SymDst to unified table                                               #   ---------------------------
    :idTd[sComp]: 0 idSymDst 0 1 idAux -lookup;                                 #   Lookup symbols in old table
    idAux idSymRef 0 0 idAux /noerror -gen_index;                               #   Get new symbol index
    idAux 0 1 sComp idTd -xstore;                                               #   Store in idTd
    idSymRef idSymDst =;                                                        #   Copy symbol table
  }

  "\n   Packing session info file ."                                      -MSG; # Protocol
  ( .sFsgFile not ) ( .sCmd "rec" == ) && if                                    # No grammar file specified >>
    " SKIPPED (no grammar file specified through key <uasr.lm.fsg>!)"           #   |
    -COLOR_yellow                                                         -MSG; #   Protocol
    1 return;                                                                   #   No service!
  end                                                                           # <<
  ( .sDlgFile not ) ( .sCmd "dlg" == ) && if                                    # No dialog file specified >>
    " SKIPPED (no dialog file specified through key <uasr.dlg.fsg>!)"           #   |
    -COLOR_yellow                                                         -MSG; #   Protocol
    1 return;                                                                   #   No service!
  end                                                                           # <<

  object iSI;                                                                   # The session info file
  fst    iSI.itLX;                                                              # - The lexicon FST
  fst    iSI.itRN;                                                              # - The recognition network
  fst    iSI.itRNr;                                                             # - The reference reognition network
  fst    iSI.itGP;                                                              # - The labelling transducer
  data   iSI.idLMtos;                                                           # - The grammar's output symbols 
  fst    iSI.itSynGrm;                                                          # - The synthesis grammar
  fst    iSI.itWom;                                                             # - The world model
  hmm    itHMM;                                                                 # The HMAs
  data   idLX;                                                                  # The lexicon entries
  fst    itDlg;                                                                 # The dialog FST
  fst    itAM;                                                                  # The preprocessed HMAs
  var    nRet;    1 nRet =;                                                     # The return value
  var    sSiFile; "$[.sDirOut]/sesinfo.object" sSiFile  =;                      # Get default output file name
  ( "out.sesinfo" sSiFile "S" -CFG_get_ex )    sSiFile  =;                      # Get configured output file name
  var    sDlgFile; "$[.sDirOut]/dialog.fst"    sDlgFile =;                      # Get default dialog file name
  ( "out.dialog" sDlgFile "S" -CFG_get_ex )    sDlgFile =;                      # Get configured dialog file name
  ( "gmm.mix" "yes" "S" -CFG_get_ex ) "yes" == var bGmmMix;                     # Get mixture creation flag
  var    s;                                                                     # Auxiliary string variable

  "\n   - Reading \"$[.sAmFile]\" ..."                                   -MSG2; # Protocol
  .sAmFile itHMM /noerror -restore                                              # Load HMMs
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors
  "dlg" .sCmd == if                                                             # Dialog mode >>
    .sDlgFile .sFsgFile =;                                                      #   Use dialog file
    "\n   - Loading dialog from \"$[.sFsgFile]\" [DLG:] ..."             -MSG2; #   Protocol
    .sFsgFile "DLG:" itDlg -FSG_load_dialog                                     #   Load grammar rules
    not if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."      -MSG; #   Check for errors
  end                                                                           # <<
  "\n   - Loading lexicon from \"$[.sFsgFile]\" [LEX:] ..."              -MSG2; # Protocol
  .sFsgFile "LEX:" idLX  -LX_load                                               # Load lexicon entries
  not if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."        -MSG; # Check for errors

  "\n   - Preparing HMMs "                                               -MSG2; # Protocol
  bGmmMix itHMM.gm.mmap NULL == && if itHMM -gmm_mix end;                       # Create mixtures
  itHMM.os -is_empty if :itHMM.ud["~NAM"]: itHMM.os = end;                      # Check/create HMM name table
  itHMM /index itAM -union; itAM 0 itAM -close;                      "." -MSG2; # Sum and close HMAs
  itAM.td ( "~RC" itAM.td -find_comp ) 1 itAM.td -delete;                       # Remove reference counter component
  itAM iSI.itRNr =;                                                             # Copy closes HMAs
  ". done" -MSG2 "."                                                      -MSG; # Protocol

  "\n   - Preparing lexicon ..."                                         -MSG2; # Protocol
  "<PAU>" itHMM.os idLX -LX_ladd_pause;                                         # Add pause word (as string)
  itHMM.os idLX iSI.itLX -LX_compile;                                           # Compile lexicon (string -> FST)
  "<OOV>" iSI.itLX.is.nrec iSI.itLX -LX_add_filler;                             # Add filler word (as FST)
  " done" -MSG2 "."                                                       -MSG; # Protocol
  .bRender if                                                                   # Rendering lexicon? Yes >>
    "$[.sDirOut]/lexicon.svg" s =; "\n   - Writing \"$[s]\" .."          -MSG2; #   Make file name/Protocol
    s iSI.itLX.is iSI.itLX.os -1 iSI.itLX -FST_render;               "." -MSG2; #   Protocol
  end                                                                           # <<

  .sCmd "dlg" == if                                                             # Dialog mode >>
    var nS;                                                                     #   The dialog state index
    var nC; ( "~NAM" itDlg.sd -find_comp ) nC =;                                #   The state name component index
    0 nS =; nS itDlg.sd.nrec < while                                            #   Loop over dialog states >>
      .sFsgFile "GRM.${itDlg.sd[nS,nC]}:" iSI -RN_add_unit;                     #     Add recognition network
      nS ++=;                                                                   #     Next dialog state
    end                                                                         #   <<
  else                                                                          # << Simple grammar mode >>
    .sFsgFile "GRM:" iSI -RN_add_unit;                                          #   Add recognition network
  end                                                                           # <<

  "\n   - Compiling labelling transducer ..."                            -MSG2; # Protocol
  itHMM iSI.itGP -LAB_get_fst;                                                  # Create labelling transducer
  " done" -MSG2 "."                                                       -MSG; # Procotol

  iSI.itRN.os iSI.idLMtos =;                                                    # Copy grammar output symbols

  ( "syn.grm" ""  "S"  -CFG_get_ex  ) var sSynGrmFile;                          # Get synthesis grammar file name
  sSynGrmFile "" != if;                                                         # If it is set >>
    "\n   - Compiling synthesis grammar ..."                             -MSG2; #   Protocol
    # Compile SynGrm                                                            #   ---------------------------
    data idSynLX;                                                               #   Synthesis lexicon
    data idSynFsg;                                                              #   Synthesis fsg
    sSynGrmFile "LEX:" idSynLX -LX_load;                                        #   Load lexicon
    sSynGrmFile "GRM:" idSynFsg -FSG_load;                                      #   Load fsg
    idSynFsg idSynLX NULL iSI.itSynGrm -FSG_compile;                            #   Compile grammar
    #"syngrm.svg" iSI.itSynGrm.is iSI.itSynGrm.os -1 iSI.itSynGrm -FST_render;                           "." -MSG2; #   Protocol

    iSI.itRN.os iSI.itSynGrm.td "~TOS" iSI.itSynGrm.os -unify_symbols;

    # Invert SynGrm                                                             #   ---------------------------
    0 iSI.itSynGrm -invert;                                                     #   Invert SynGrm
  end;                                                                          # <<
  
  ( "wom.dir" ""  "S"  -CFG_get_ex  ) var sWomDir;                              # Get world model directory
  sWomDir "" != if;                                                             # If it is set >>
    "\n   - Loading world models ..."                                    -MSG2; #   Protocol
    data idLst; sWomDir "*.fst" TRUE idLst -SH_find;                            #   Find all model files
    fst itMod;                                                                  #   Model variable
    0 var f; f idLst.nrec < while;                                              #   Loop over model files >>
      "$[sWomDir]/${idLst[f,0]}" itMod -restore;                                #     Load model
      "~TOS" -type long itMod.td -addcomp;                                      #     Add output symbols
      0 itMod -invert;                                                          #     Invert model
      iSI.itRN.os itMod.td "~TOS" itMod.os -unify_symbols;                      #     Unify symbols with itRN
      itMod iSI.itWom -cat;                                                     #     Cat to world model pool
    f ++=; end;                                                                 #   <<
  end;                                                                          # <<

  iSI.itRN.os iSI.idLMtos =;
  iSI.itRN.os iSI.itSynGrm.is =;

  retDlg NULL != if; itDlg retDlg =; end;                                       # Return dialog model
  retSI  NULL != if; iSI   retSI  =; 1 return; end;                             # Return session info object

  ## Write output files
  "\n   - Writing \"$[sSiFile]\" ..."                                    -MSG2; # Protocol
  .__CFG_bNwr not if                                                            # Not write-protected >>
    sSiFile iSI /zip -save                                                      #   Save session info file
    ?error if " FAILED" -COLOR_red -MSG; 0 nRet =; end " ok" -MSG2; "."   -MSG; #   Check for errors
  else                                                                          # << Write protected >>
    " SKIPPED (write protection on!)" -COLOR_yellow                      -MSG2; #   Protocol
  end                                                                           # <<
  
  .sCmd "dlg" == if                                                             # Dialog mode >>
    "\n   - Writing \"$[sDlgFile]\" ..."                                 -MSG2; #   Protocol
    .__CFG_bNwr not if                                                          #   Not write-protected >>
      sDlgFile itDlg /zip -save                                                 #     Save dialog file
      ?error if " FAILED" -COLOR_red -MSG; 0 nRet =; end " ok" -MSG2; "." -MSG; #     Check for errors
    else                                                                        #   << Write protected >>
      " SKIPPED (write protection on!)" -COLOR_yellow                    -MSG2; #     Protocol
    end                                                                         #   <<
  else                                                                          # << Normal mode >>
    "\n   - Remove \"$[sDlgFile]\" ..."                                  -MSG2; #   Protocol
    .__CFG_bNwr not if                                                          #   Not write-protected >>
      sDlgFile -SH_rm;                                                          #     Remove dialog file
    else                                                                        #   << Write protected >>
      " SKIPPED (write protection on!)" -COLOR_yellow                    -MSG2; #     Protocol
    end                                                                         #   <<
  end                                                                           # <<

  "\n  " -MSG2; " ok"                                                     -MSG; # Protocol
  nRet return;                                                                  # All right
}

## Packs all files for ssmg recognizer
function -PACK_ssmg()
{
  ## Get parameter objects                                                      # -------------------------------------
  object iFI;            iFI       -PACK_feainfo;                               # Get feature info object
  gmm    itGm;           itGm      -PACK_gmm;                                   # Get gaussian mixture model
  object iSI; fst itDlg; iSI itDlg -PACK_sesinfo;                               # Get session info object + dialog model
  object iVAD; .sVadFile iVAD -restore;                                         # Load vad model

  ## Init FBAproc for window                                                    # -------------------------------------
  ( "pfa" "" -CFG_get ) -FEA_pfa_init;                                          # Init .__FEA_iPfa
  data idSig; 1 1000 ones idSig =;                                              # Create a short signal
  :1000/.__FEA_iPfa.srate: idSig -set rinc;                                     # Set record increment
  idSig NULL idSig NULL .__FEA_iPfa -analyze;                                   # Analyze the signal for window initialization

  ## Pack it                                                                    # -------------------------------------
  .__FEA_iPfa.window          -PACK_fftw;
                              -PACK_logs;
                              -PACK_mel;
  iFI  itGm.mean.dim      ""  -PACK_pca;
  iVAD iVAD.itGm.mean.dim "0" -PACK_pca;
  itGm                    ""  -PACK_mahala;
  iVAD.itGm               "0" -PACK_mahala;
  itGm.mmap               ""  -PACK_gmmmix;
  iVAD.itGm.mmap          "0" -PACK_gmmmix;
                              -PACK_gmms;
  iSI                         -PACK_recodata;                                                           #   Pack recodata file
  itDlg                       -PACK_dialog;                                                           #   Pack dialog file
                              -PACK_pade;
                              -PACK_keytab;
  .sSynDir .sSynMod           -PACK_syn;
}

## Packs all files for recfix
function -PACK_recfix()
{
  ## Get parameter objects                                                      # -------------------------------------
  object iFI;  iFI      -PACK_feainfo;                                          # Get feature info object
  gmm    itGm; itGm     -PACK_gmm;                                              # Get gaussian mixture model
  fst    itDlg;                                                                 # The dialog FST
  object iSI;  iSI itDlg -PACK_sesinfo;                                         # Get session info object


  data idHist; -UPFA_hist idHist =;
  idHist -NRM_Calc;

  ## Pack it                                                                    # -------------------------------------
  data idSynWrds; idSynWrds -PACK_synsig;                                       # Pack synthesis signals
  1 var nrm;                                                                    # Init nomalization value
  .sFDsp -SH_rm;                                                                # Remove old output file
  7 1  "version" "u16"     -PACK1;                                              # Pack version number
  0 1  "_blank1" "u16"     -PACK1;                                              # Pack blank
  nrm                      -PACK_sig;                                           # Pack frontend information
  nrm                      -PACK_pfa nrm =;                                     # Pack primary feature analysis parameters
  nrm iFI itGm.mean.dim    -PACK_sfa nrm =;                                     # Pack secondary feature analysis parameters
  nrm itGm                 -PACK_gau nrm =;                                     # Pack gaussian parameters
  nrm itGm.mmap            -PACK_mix nrm =;                                     # Pack mixture parameters
  nrm iSI.itRN             -PACK_fsts;                                          # Pack recognition networks
  nrm iSI.itRNr 0 "S" TRUE -PACK_fst;                                           # Pack reference recognition network
  nrm itDlg    0 "Sw" TRUE -PACK_fst;                                           # Pack dialog grammar
  nrm iSI.itGP             -PACK_cnf;                                           # Pack reference recognition network
  nrm                      -PACK_trg;                                           # Pack signal detection
  iSI.itSynGrm idSynWrds   -PACK_syngrm;                                        # Pack synthesis grammar
  iSI.itWom                -PACK_wom;                                           # Pack synthesis grammar
  "\n  => Final norm: $[nrm]"                                             -MSG; # Protocol
}

## Packs the VAD info file
function -PACK_vadinfo()
{
  "IMPLEMENTATION INCOMPLETE!" -ERROR;                                          # !!! NOT USABLE
  0 return;                                                                     # !!!

  object iFI;
  hmm    itHMM;
  gmm    iGm;
  object iVAD;
  data   iVAD.idX;
  data   iVAD.idW;
  gmm    iVAD.itGm;
  var    sOutFile;  "$[.sDirOut]/$[.sAm].vad" sOutFile =;                       # Get default output file name
  ( "out.vad" sOutFile "S" -CFG_get_ex )      sOutFile =;                       # Get configured output file name
  "\n   Packing voice activity detection info file ."                     -MSG; # Protocol
  "\n   - Reading \"$[.sFiFile]\" ..."                                   -MSG2; # Protocol
  .sFiFile iFI /noerror -restore                                                # Read feature info file
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors
  "\n   - Reading \"$[.sAmFile]\" ..."                                   -MSG2; # Protocol
  .sAmFile itHMM /noerror -restore                                              # Read acoustic model file
  ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."     -MSG; # Check for errors

  "\n   - Compiling VAD info ."                                          -MSG2;
  itHMM -gmm_mix;                                                    "." -MSG2;
  iFI.idX  iVAD.idX  =;
  iFI.idW  iVAD.idW  =;
  itHMM.gm iVAD.itGm =;                                              "." -MSG2;
  " done" -MSG2 "."                                                       -MSG;

  "\n   - Writing \"$[sOutFile]\" ..."                                   -MSG2; # Protocol
  .__CFG_bNwr not if                                                            # Not write-protected >>
    sOutFile iVAD /zip -save                                                    #   Save VAD info file
    ?error if " FAILED" -COLOR_red -MSG; 0 return; end " ok" -MSG2; "."   -MSG; #   Check for errors
  else                                                                          # << Write protected >>
    " SKIPPED (write protection on!)" -COLOR_yellow                      -MSG2; #   Protocol
  end "\n  " -MSG2; " ok" -MSG;                                                 # <<

  1 return;                                                                     # All right
}

## == MAIN PROGRAM ==                                                           # =====================================

( "$1" "xtpx" == ) if                                                           # Create self-contained prg. archive >> 
  var sXtpxFile; "$__FILE__" "x" + sXtpxFile =;                                 #   Make target file name
  "\nCreating " sXtpxFile + " ..." +                                      -MSG; #   Protocol
  sXtpxFile this /zip -save;                                                    #   Save program object
  ( "$1" "xtpx" == ) if " done.\n" -MSG; quit; end                              #   Quit after saving archive
end                                                                             # <<
-UASR_silence;                                                                  # Detect silent mode
"\n// UASR - UNIFIED APPROACH TO SPEECH SYNTHESIS AND RECOGNITION"        -MSG; # Protocol               
"\n// $__SFILE__.xtp"                                                     -MSG; # Protocol
"\n// Process         : $HOSTNAME/" -pid +                                -MSG; # Protocol
"\n// dLabPro VID     : " -version +                                      -MSG; # Protocol
"\n// UASR VID        : " -UASR_version +                                 -MSG; # Protocol
( "$1" "help" == ) -UASR_help || if "$2" -usage; 0 return; end                  # Print help
"$1" var sCmd;                                                                  # Get command
sCmd "dlg" ==                                                                   # | Pack dialog recognition data
sCmd "rec" == ||                                                                # | Pack simple recognition data
sCmd "vad" == ||                                                                # | Pack VAD data
not ( $$ 2 < ) || if                                                            # Bad command or less than 2 args. >> 
  $$ 2 < if "Too few arguments" else "unknown command '$1'"  end   -ERROR;      #   Error
  "\nType '$__SFILE__.xtp help' for usage\n" -echo;                             #   Give a little help
  1 return;                                                                     #   Terminate with error code
end                                                                             # <<
"\n// Configuration   : $2"                                               -MSG; # Protocol
"$2" FALSE -CFG_init;                                                           # Configure session
"../util/uasr_session.itp" include;                                             # Include UASR session startup script

## Start up                                                                     # -------------------------------------
"\n\n// RECOGNIZER DATA PACKAGING: "                                      -MSG; # Protocol
sCmd "dlg" == if "RECOGNITION (DIALOG)"         -MSG; end                       # Protocol
sCmd "rec" == if "RECOGNITION (SIMPLE GRAMMAR)" -MSG; end                       # Protocol
sCmd "vad" == if "VOICE ACTIVITY DETECTION"     -MSG; end                       # Protocol
.__CFG_bNwr if "\n   - Write protect : " "ON" -COLOR_yellow + -MSG; end         # Protocol
var sOutTyp;  ( "outtyp"  "R" "S"  -CFG_get_ex  ) sOutTyp  =;                   # Get the output type
var sDirMod;  ( "model" "S"       -CFG_get_path ) sDirMod  =;                   # Get UASR model directory
var sFiFile;  "$[sDirMod]/feainfo.object"         sFiFile  =;                   # Feature info object file
var sAm;      ( "am.model" "3_10" -CFG_get      ) sAm      =;                   # Get acoustic model ID
var sAmFile   "$[sDirMod]/$[sAm].hmm"             sAmFile  =;                   # Acoustic model file
var sFsgFile; ( "lm.fsg"  ""  "S"  -CFG_get_ex  ) sFsgFile =;                   # Grammar file
var sDlgFile; ( "dlg.fsg" ""  "S"  -CFG_get_ex  ) sDlgFile =;                   # Dialog file
var sDirOut;  ( "out"     "." "S"  -CFG_get_ex  ) sDirOut  =;                   # Output directory
var bRender;  ( ( "render" "" "S"  -CFG_get_ex  ) "yes"     == ) bRender  =;    # FST rendering flag 
var bExpOfst; ( ( "export" "" "S"  -CFG_get_ex  ) "openFST" == ) bExpOfst =;    # Export openFST flag 
var sSkip;    ( "skip"    ""  "S"  -CFG_get_ex  ) sSkip    =;                   # Skip flags
var bOk; TRUE bOk =;                                                            # OK flag
( sFiFile  "Feature info"   TRUE  -FCHK ) bOk && bOk =;                         # Info on feature info file
( sAmFile  "Acoustic model" TRUE  -FCHK ) bOk && bOk =;                         # Info on acoustic model file
sCmd "dlg" == if                                                                # Command 'dlg' >>
  ( sDlgFile "Dialog"       TRUE  -FCHK ) bOk && bOk =;                         #   Info on dialog file
end                                                                             # <<
sCmd "rec" == if                                                                # Command 'rec' >>
  -FFSG  bOk && bOk =;                                                          #   Check/create grammar file
end                                                                             # <<
bOk not if                                                                      # One or several files not found >>
  "Input file(s) not found. Check protocol above." -ERROR;                      #   Error message
  goto L_EXCEPTION;                                                             #   No go!
end                                                                             # <<
"\n   - Output folder : $[sDirOut]"                                       -MSG; # Protocol
"\n   - SVG rendering : " ( bRender  if "yes" else "no" end ) +           -MSG; # Protocol
"\n   - openFST export: " ( bExpOfst if "yes" else "no" end ) +           -MSG; # Protocol

## Output type specific includes                                                # -------------------------------------
sOutTyp "S" == if;                                                              # For ssmg demonstrator >>
  sCmd "vad" == if;                                                             #   Command 'vad' >>
   "UNSUPPORTED command $[sCMD] for output type $[sOutTyp]" 0 -WARNING; quit;   #     Warn unsupported
  end;                                                                          #   <<
  "$[.sDirOut]/ssmg"           var sDirDsp;                                     #   Set output directory
  "$[.sDirOut]/3_10_mod.vad"   var sVadFile;                                    #   Default VAD file name
  "$[.sDirOut]/syn"            var sSynDir;                                     #   Default synthesis directory
  "3_20"                       var sSynMod;                                     #   Default synthesis model
  "vad.model" sVadFile "S" -CFG_get_ex sVadFile =;                              #   Get VAD file name
  "syn.dir"   sSynDir  "S" -CFG_get_ex sSynDir  =;                              #   Get synthesis directory
  "syn.model" sSynMod  "S" -CFG_get_ex sSynMod  =;                              #   Get synthesis model
end;                                                                            # <<
sOutTyp "F" == if;                                                              # For recfix >>
  sCmd "vad" == if;                                                             #   Commands 'dlg' and 'vad' >>
   "UNSUPPORTED command $[sCmd] for output type $[sOutTyp]" 0 -WARNING; quit;   #     Warn unsupported
  end;                                                                          #   <<
  "recfix.prnw"    0 -CFG_get var nPRNW;                                        #   Weight pruning threshold
  "$[.sDirOut]/recfix.cfg"   var sFDsp;                                         #   Output file name
end;                                                                            # <<


## Pack data                                                                    # -------------------------------------
( sCmd "dlg" == ) ( sCmd "rec" == ) || if                                       # Commands 'dlg' and 'rec' >>
  sOutTyp "R" == if                                                             #   For recognizer >>
    sSkip if                                                                    #     Skipping something >>
      "\n   - Skip          :"                                            -MSG; #       Protocol
      ( sSkip "F" "search" -VAR_strop ) 0 >= if " feainfo" -MSG; end            #       Protocol
      ( sSkip "G" "search" -VAR_strop ) 0 >= if " GMM"     -MSG; end            #       Protocol
      ( sSkip "S" "search" -VAR_strop ) 0 >= if " sesinfo" -MSG; end            #       Protocol
    end                                                                         #     <<
    "\n"                                                                  -MSG; #       Protocol
    ( sSkip "F" "search" -VAR_strop ) 0 < if NULL      -PACK_feainfo; end       #     Pack feature info file
    ( sSkip "G" "search" -VAR_strop ) 0 < if NULL      -PACK_gmm;     end       #     Pack Gaussian mixture model file
    ( sSkip "S" "search" -VAR_strop ) 0 < if NULL NULL -PACK_sesinfo; end       #     Pack ession info file
    goto L_END;                                                                 #     --> End
  end                                                                           #   <<
  sOutTyp "S" == if -PACK_ssmg;   goto L_END; end                               #   For ssmg demonstrator
  sOutTyp "F" == if -PACK_recfix; goto L_END; end                               #   For recfix
end                                                                             # <<
sCmd "vad" == if                                                                # Command 'vad' >>
  "\n\n"                                                                  -MSG; #   Protocol
  -PACK_vadinfo;                                                                #   Pack VAD info file
  goto L_END;                                                                   #   --> End
end                                                                             # <<

## Finish                                                                       # -------------------------------------
label L_END;                                                                    # :END
"\n\n// $__SFILE__.xtp completed (${.__UTL_nErrors} errors)."             -MSG; # Protocol
.__CFG_bNwr if "Write protection on. No files written!" 1 -WARNING; end         # Write-protected-warning
"\n\n"                                                                    -MSG; # Protocol
0 return;                                                                       # Indicate success

label L_EXCEPTION;                                                              # :EXCEPTION
"\n\n// $__SFILE__.xtp FAILED (${.__UTL_nErrors} errors)."                -MSG; # Protocol
"\n\n**  Try '$__SFILE__.xtp help $[sCmd]' or see manual! **\n\n"         -MSG; # Protocol
1 return;                                                                       # Indicate failure

## EOF
